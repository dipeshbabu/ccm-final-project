'''
This file contains code to compute all possible states in a game of blackjack. The states are represented as tuples of player and dealer hands (specifically just the rank of the cards). The state space is generated by considering all possible combinations of player and dealer hands that are valid based on the maximum card counts in the deck. The state space is saved to a binary file using the pickle module.
'''

from itertools import combinations_with_replacement
from collections import Counter
from typing import List, Tuple
import pickle as pkl

import os
import sys
import pickle as pkl

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from globals import *


def is_valid_hand(hand, max_card_counts):
    """
    Check if a hand is valid based on the maximum card counts in the deck.
    """
    # Count the occurrences of each card in the hand
    hand_counts = Counter(hand)
    # Check if the count of each card in the hand is less than or equal to the maximum count
    for card, count in hand_counts.items():
        # If the count exceeds the maximum count, the hand is invalid
        if count > max_card_counts[card]:
            return False
    return True

def calculate_hand_value(hand):
    """
    Calculate the total value of a hand, treating Aces (11) as either 11 or 1.
    """
    total = sum(hand)
    num_aces = hand.count(11)

    # Adjust Aces from 11 to 1 if the total exceeds 21
    while total > 21 and num_aces > 0:
        total -= 10
        num_aces -= 1

    return total

def max_len_hand(full_deck = FULL_DECK, max_value = 21):
  '''
  Calculate the maximum length of a hand that can be drawn without exceeding the maximum value.
  '''
  # Create a copy of the full deck
  deck_copy = full_deck.copy()

  # Replace the value of Aces (11) with 1 if the total exceeds the maximum value. We do this because we want to find the maximum length of a hand that can be drawn without exceeding 21.
  for i in deck_copy:
    if i == 11:
      deck_copy.remove(i)
      deck_copy.append(1)
  # Sort the deck in descending order. This allows us to draw the highest value cards first.
  reverse_sorted_deck = sorted(deck_copy, reverse = True)

  # tracking the min hand
  min_hand = []

  # Calculate the maximum length of a hand that can be drawn without exceeding the maximum value
  for i in range(1,len(reverse_sorted_deck)):
    # If the sum of the min_hand is less than the maximum value, add the card to the min_hand
    if sum(min_hand) < max_value:
      min_hand.append(reverse_sorted_deck[-i])
    else:
      return len(min_hand)

def generate_state_space(max_card_counts):
    """
    Generate all possible unique combinations of player and dealer hands.
    Each state is represented as a tuple: (player_hand, dealer_hand).
    """
    state_space = []

    # Generate all possible hands for player and dealer
    all_hands = []
    max_hand_length = max_len_hand()
    # Iterate over all possible hand lengths
    for r in range(1, max_hand_length+1):
        # Generate all possible combinations of cards with replacement
        for hand in combinations_with_replacement(CARDS, r):
            if is_valid_hand(hand, max_card_counts) and calculate_hand_value(hand) <= 21:
                all_hands.append(hand)

    # Create state combinations for player and dealer hands. The state space includes the terminal states as well. ((-1), (0) represents the terminal state where the players hand exceeds 21. ((player_hand), (-1)) represents the terminal state where the player does not bust but the dealer busts
    state_space.append((((-1)),((0))))
    for player_hand in all_hands:
        if len(player_hand) >= 2:
          state_space.append(((player_hand), ((-1))))
          for dealer_hand in all_hands:
              # Ensure the combined hands don't exceed the total card limits
              combined_hand = player_hand + dealer_hand
              if is_valid_hand(combined_hand, max_card_counts):
                  player_value = calculate_hand_value(player_hand)
                  dealer_value = calculate_hand_value(dealer_hand)
                  # Represent the state by the hand values (player, dealer)
                  state_space.append(((player_hand), (dealer_hand)))

    return state_space

def save_state_space(state_spaces, filename = "states.pkl"):
    """
    Save the state space to a file.
    """
    # File path to save the binary file
    output_file = filename

    # Save the states to a binary file
    with open(output_file, 'wb') as pklfile:
        pkl.dump(state_spaces, pklfile)

    print(f"States exported to {output_file}")

def main(filename = "optimal_policy_training/states.pkl"):
    # Generate the state space
    state_space = generate_state_space(CARD_COUNTS)
    #print(f"Number of States: {len(state_space)}")

    # Save the state space to a file
    save_state_space(state_space,filename)


# Run the main function to generate and save the state space
#main("optimal_policy_training/states3.pkl")
